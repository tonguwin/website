---
import BaseLayout from "../../layouts/BaseLayout.astro";

const post = {
  title: "Jumpboy",
  date: "March 11, 2025",
  content: `
    Make it out, boy.
  `
};
---

<BaseLayout>
  <!-- Add meta viewport tag for better mobile scaling -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" slot="head" />

  <div class="min-h-screen bg-secondary px-4 sm:px-8 py-8 sm:py-16">
    <div class="max-w-3xl mx-auto">
      <div class="flex justify-between items-center mb-6 sm:mb-8" data-aos="fade-up" data-aos-duration="1000">
        <h1 class="text-3xl sm:text-4xl font-bold text-primary hover:text-white transition-colors duration-300">
          Jumpboy
        </h1>
      </div>

      <div class="relative">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
        <button 
          id="startButton" 
          class="absolute top-[60%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-lg transition-colors duration-300"
        >
          Start
        </button>
        <div id="gameOver" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black/80 text-white p-8 rounded-lg text-center">
          <h2 class="text-2xl mb-4">Game Over</h2>
          <p class="mb-4">Score: <span id="score">0</span></p>
          <p class="text-sm">Jump to Restart</p>
        </div>
      </div>
      
      <!-- Score display below the canvas -->
      <div id="scoreDisplay" class="mt-4 text-white text-xl font-bold">
        Score: <span id="scoreValue">0</span>
      </div>

      <!-- Items section -->
      <div id="itemsSection" class="mt-4 flex justify-end">
        <div id="pointyHatItem" class="hidden w-8 h-8 relative cursor-pointer">
          <canvas id="pointyHatCanvas" class="w-full h-full"></canvas>
        </div>
        <div id="greensGluttonyItem" class="hidden w-8 h-8 relative cursor-pointer ml-2">
          <canvas id="greensGluttonyCanvas" class="w-full h-full"></canvas>
        </div>
      </div>

      <!-- Item Modal -->
      <div id="itemModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50">
        <div class="bg-black/80 p-6 rounded-lg max-w-sm w-full">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold text-white" id="itemModalTitle">Pointy Hat</h3>
            <button id="closeModal" class="text-white hover:text-gray-300">✕</button>
          </div>
          <div class="flex items-center justify-center mb-4">
            <canvas id="itemModalCanvas" class="w-16 h-16"></canvas>
          </div>
          <p class="text-white text-center" id="itemModalDescription">A white oversized birthday hat. Seems like a lame birthday.</p>
        </div>
      </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls" class="fixed bottom-0 left-0 w-full h-32 bg-black/20 backdrop-blur-sm flex items-center justify-between px-8 md:hidden">
      <div class="flex space-x-4">
        <button id="leftBtn" class="w-16 h-16 rounded-full bg-white/20 flex items-center justify-center text-white text-2xl">
          ←
        </button>
        <button id="rightBtn" class="w-16 h-16 rounded-full bg-white/20 flex items-center justify-center text-white text-2xl">
          →
        </button>
      </div>
      <button id="jumpBtn" class="w-20 h-20 rounded-full bg-red-500/80 flex items-center justify-center text-white text-xl font-bold">
        Jump!
      </button>
    </div>

    <a 
      href="/blog/secret-blog" 
      class="inline-block mt-8 text-primary/60 hover:text-white transition-colors duration-300"
    >
      ← Back to Blog
    </a>
  </div>

  <style>
    .min-h-screen {
      position: relative;
      overflow: hidden;
    }

    .max-w-3xl {
      position: relative;
      z-index: 1;
    }

    #gameCanvas {
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    /* Update hover effects to use white */
    .prose :is(a, button):hover {
      color: white !important;
    }

    /* Mobile Controls Styles */
    #mobileControls button {
      transition: all 0.1s ease;
    }

    #mobileControls button:active {
      transform: scale(0.95);
    }

    #mobileControls #leftBtn:active,
    #mobileControls #rightBtn:active {
      background-color: rgba(255, 255, 255, 0.3);
    }

    #mobileControls #jumpBtn:active {
      background-color: rgba(239, 68, 68, 0.9);
    }

    /* Hide mobile controls on desktop */
    @media (min-width: 768px) {
      #mobileControls {
        display: none;
      }
    }
  </style>

  <script>
    // Game constants
    const GRAVITY = 0.5;
    const JUMP_FORCE = -12;
    let MOVE_SPEED = 4;
    const PLATFORM_HEIGHT = 12;
    const PLATFORM_WIDTH = 100;
    const MONSTER_SIZE = 30;
    const LARGE_MONSTER_SIZE = 40;
    const SMALL_MONSTER_SIZE = 20;
    const PLAYER_SIZE = 20;
    const SCREEN_SCROLL_THRESHOLD = 0.7;
    const ADVANCED_MONSTER_SCORE = 200;
    const FAST_MONSTER_SCORE = 400;
    const HYBRID_MONSTER_SCORE = 1000;
    const ULTIMATE_MONSTER_SCORE = 900;
    const PLATFORM_SPACING = 60;  // Reduced from 80 to 60
    const EASY_PLATFORM_SPACING = 50;  // Reduced from 60 to 50
    const MIN_PLATFORMS = 12;  // Increased from 15 to 20
    const PLATFORM_BUFFER = 5;  // Increased from 3 to 5
    const MAX_JUMP_DISTANCE = 200;  // Maximum horizontal distance between platforms
    const MONSTER_SPAWN_CHANCE = 0.4;
    const EASY_MONSTER_SPAWN_CHANCE = 0.2;
    const VERY_EASY_MONSTER_SPAWN_CHANCE = 0.05;
    const MAX_PARTICLES = 80;
    const PARTICLE_LIFETIME = 1;
    const PARTICLE_DECAY = 0.02;
    const CYAN_DUPLICATION_CHANCE = 0.45;
    const DOUBLE_JUMP_UNLOCK_SCORE = 700;
    const CUTSCENE_DURATION = 3000;
    const RAINBOW_COLORS = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#8f00ff'];
    const EASY_MODE_THRESHOLD = 300;
    const BRITTLE_PLATFORM_SCORE = 350;
    const BRITTLE_PLATFORM_CHANCE = 0.45;
    const BRITTLE_PLATFORM_BREAK_TIME = 1500;
    const POINTY_HAT_SCORE = 200;
    const GREENS_GLUTTONY_DROP_CHANCE = 0.20; // 20% drop chance from green monsters
    const PLAYER_ENLARGED_SIZE = 40; // Same size as green monster (LARGE_MONSTER_SIZE)
    const ENLARGED_MOVE_SPEED = 1.5; // Slower movement speed when enlarged
    const PLAYER_GLUTTONY_SIZE = 35; // Slightly larger than red monster

    // Device-specific speed adjustments
    let isMobileDevice = false;
    let speedMultiplier = 1.0;
    let mobileMoveSpeed = 3;
    let desktopMoveSpeed = 4;
    let mobileMonsterSpeedMultiplier = 0.8;
    let desktopMonsterSpeedMultiplier = 1.0;
    let canvasScale = 1.0;

    // Additional variables for growth animation
    let growthStartTime = 0;
    let growthProgress = 0;
    let isGrowing = false;
    const GROWTH_DURATION = 1500; // 1.5 seconds for the growth animation

    // Type definitions
    interface Particle {
      x: number;
      y: number;
      color: string;
      size: number;
      speedX: number;
      speedY: number;
      life: number;
      decay: number;
      update(): void;
      draw(ctx: CanvasRenderingContext2D): void;
    }

    interface Platform {
      x: number;
      y: number;
      width: number;
      height: number;
      type?: 'normal' | 'brittle';
      breakTimer?: number;
    }

    interface Monster {
      x: number;
      y: number;
      width: number;
      height: number;
      direction: number;
      type: 'basic' | 'advanced' | 'fast' | 'hybrid';
      color: string;
      speed: number;
      verticalSpeed?: number;
      verticalDirection?: number;
      hasDuplicated: boolean;
    }

    interface Player {
      x: number;
      y: number;
      width: number;
      height: number;
      velocityY: number;
      velocityX: number;
      isJumping: boolean;
      hasDoubleJump: boolean;  // Only need this flag
      wasJumping: boolean;
      isInCutscene: boolean;
      rainbowTimer: number;
      currentRainbowIndex: number;
      hasPointyHat: boolean;  // New property for the pointy hat
      hasGreensGluttony: boolean;  // Initialize Green's Gluttony
      isEnlarged: boolean;  // Track if player is enlarged
    }

    interface Item {
      x: number;
      y: number;
      width: number;
      height: number;
      type: 'pointyHat' | 'greensGluttony';
      collected: boolean;
    }

    interface GameKeys {
      left?: boolean;
      right?: boolean;
      [key: string]: boolean | undefined;
    }

    // Particle system
    class Particle implements Particle {
      constructor(x: number, y: number, color: string) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 3 + 1;
        this.speedX = (Math.random() - 0.5) * 4;
        this.speedY = (Math.random() - 0.5) * 4;
        this.life = 1;
        this.decay = 0.02 + Math.random() * 0.02;
      }

      update(): void {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= this.decay;
      }

      draw(ctx: CanvasRenderingContext2D): void {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
      }
    }

    // Game state
    let canvas: HTMLCanvasElement;
    let ctx: CanvasRenderingContext2D;
    let player: Player = {
      x: 0,
      y: 0,
      width: PLAYER_SIZE,
      height: PLAYER_SIZE,
      velocityY: 0,
      velocityX: 0,
      isJumping: false,
      hasDoubleJump: false,  // Only need this flag
      wasJumping: false,
      isInCutscene: false,
      rainbowTimer: 0,
      currentRainbowIndex: 0,
      hasPointyHat: false,  // Initialize pointy hat
      hasGreensGluttony: false,  // Initialize Green's Gluttony
      isEnlarged: false  // Track if player is enlarged
    };

    let platforms: Platform[] = [];
    let monsters: Monster[] = [];
    let items: Item[] = [];  // New array for items
    let particles: Particle[] = [];
    let score = 0;
    let gameOver = false;
    let gameStarted = false;
    let keys: GameKeys = {};
    let cameraY = 0;
    let titleFlicker = true;
    let flickerTimer = 0;
    let lastTime = 0;
    let frameCount = 0;
    let fps = 0;
    let cutsceneStartTime = 0;
    let currentDialogue = 0;
    let pointyHatCutsceneStartTime = 0;
    let pointyHatCutscenePhase = 0;
    let greensGluttonyCutsceneStartTime = 0;
    let greensGluttonyCutscenePhase = 0;

    // Add a flag to track if the pointy hat has been spawned
    let pointyHatSpawned = false;

    // Add a counter for Green's Gluttony drops
    let greensGluttonyDropCount = 0;

    // Initialize item display
    function initItemDisplay() {
      const pointyHatCanvas = document.getElementById('pointyHatCanvas') as HTMLCanvasElement;
      const pointyHatCtx = pointyHatCanvas.getContext('2d')!;
      const itemModalCanvas = document.getElementById('itemModalCanvas') as HTMLCanvasElement;
      const itemModalCtx = itemModalCanvas.getContext('2d')!;
      
      // Set canvas sizes with mobile scaling
      const itemSize = isMobileDevice ? 24 : 32;
      const modalSize = isMobileDevice ? 48 : 64;
      
      pointyHatCanvas.width = itemSize;
      pointyHatCanvas.height = itemSize;
      itemModalCanvas.width = modalSize;
      itemModalCanvas.height = modalSize;
      
      // Draw pointy hat on both canvases
      function drawPointyHat(ctx: CanvasRenderingContext2D, width: number, height: number) {
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(width / 2, 0);
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
      }
      
      drawPointyHat(pointyHatCtx, itemSize, itemSize);
      drawPointyHat(itemModalCtx, modalSize, modalSize);
      
      // Add Green's Gluttony Canvas
      const greensGluttonyCanvas = document.getElementById('greensGluttonyCanvas') as HTMLCanvasElement;
      if (greensGluttonyCanvas) {
        const greensGluttonyCtx = greensGluttonyCanvas.getContext('2d')!;
        greensGluttonyCanvas.width = itemSize;
        greensGluttonyCanvas.height = itemSize;
        
        // Draw green orb
        drawGreenOrb(greensGluttonyCtx, itemSize, itemSize);
      }
      
      // Add click handlers with touch support
      const pointyHatItem = document.getElementById('pointyHatItem');
      const greensGluttonyItem = document.getElementById('greensGluttonyItem');
      const itemModal = document.getElementById('itemModal');
      const closeModal = document.getElementById('closeModal');
      
      if (pointyHatItem && greensGluttonyItem && itemModal && closeModal) {
        const showModal = (title: string, description: string, type: string) => {
          const itemModalTitle = document.getElementById('itemModalTitle');
          const itemModalDescription = document.getElementById('itemModalDescription');
          const itemModalCanvas = document.getElementById('itemModalCanvas') as HTMLCanvasElement;
          const itemModalCtx = itemModalCanvas.getContext('2d')!;
          
          if (itemModalTitle && itemModalDescription) {
            itemModalTitle.textContent = title;
            itemModalDescription.textContent = description;
            
            // Clear previous drawing
            itemModalCtx.clearRect(0, 0, modalSize, modalSize);
            
            // Draw appropriate item
            if (type === 'pointyHat') {
              drawPointyHat(itemModalCtx, modalSize, modalSize);
            } else if (type === 'greensGluttony') {
              drawGreenOrb(itemModalCtx, modalSize, modalSize);
            }
            
            itemModal.classList.remove('hidden');
          }
        };
        
        const hideModal = () => itemModal.classList.add('hidden');
        
        pointyHatItem.addEventListener('click', () => {
          showModal('Pointy Hat', 'A white oversized birthday hat. Seems like a lame birthday.', 'pointyHat');
        });
        
        pointyHatItem.addEventListener('touchstart', (e) => {
          e.preventDefault();
          showModal('Pointy Hat', 'A white oversized birthday hat. Seems like a lame birthday.', 'pointyHat');
        });
        
        greensGluttonyItem.addEventListener('click', () => {
          showModal('Green\'s Gluttony', 'A small glowing green orb. It makes you feel... hungry.', 'greensGluttony');
        });
        
        greensGluttonyItem.addEventListener('touchstart', (e) => {
          e.preventDefault();
          showModal('Green\'s Gluttony', 'A small glowing green orb. It makes you feel... hungry.', 'greensGluttony');
        });
        
        closeModal.addEventListener('click', hideModal);
        closeModal.addEventListener('touchstart', (e) => {
          e.preventDefault();
          hideModal();
        });
      }
    }
    
    // Draw Green Orb function
    function drawGreenOrb(ctx: CanvasRenderingContext2D, width: number, height: number) {
      // Create gradient for glowing effect
      const gradient = ctx.createRadialGradient(
        width/2, height/2, 0,
        width/2, height/2, width/2
      );
      gradient.addColorStop(0, '#00ff00');
      gradient.addColorStop(0.7, '#00aa00');
      gradient.addColorStop(1, '#007700');
      
      // Draw the orb
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(width/2, height/2, width/2 - 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Add highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.beginPath();
      ctx.arc(width/3, height/3, width/6, 0, Math.PI * 2);
      ctx.fill();
    }

    // Update item display
    function updateItemDisplay() {
      const pointyHatItem = document.getElementById('pointyHatItem');
      const greensGluttonyItem = document.getElementById('greensGluttonyItem');
      
      if (pointyHatItem) {
        if (player.hasPointyHat) {
          pointyHatItem.classList.remove('hidden');
        } else {
          pointyHatItem.classList.add('hidden');
        }
      }
      
      if (greensGluttonyItem) {
        if (player.hasGreensGluttony) {
          greensGluttonyItem.classList.remove('hidden');
        } else {
          greensGluttonyItem.classList.add('hidden');
        }
      }
    }

    // Initialize game
    function init() {
      canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
      ctx = canvas.getContext('2d')!;
      
      // Initialize item display
      initItemDisplay();
      
      // Detect mobile device and set appropriate settings
      isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      // Set speed multiplier and canvas scale based on device
      if (isMobileDevice) {
        speedMultiplier = 1.2;
        MOVE_SPEED = mobileMoveSpeed;
        canvasScale = window.innerWidth < 600 ? 0.8 : 1.0; // Scale down on very small screens
      } else {
        speedMultiplier = 0.7;
        MOVE_SPEED = desktopMoveSpeed;
        canvasScale = 1.0;
      }
      
      // Set canvas size with scaling
      canvas.width = 600 * canvasScale;
      canvas.height = 600 * canvasScale;
      
      // Set initial player position
      player.x = canvas.width / 2;
      player.y = canvas.height - 100;
      
      // Generate initial platforms
      generatePlatforms();
      
      // Start game loop with timestamp
      requestAnimationFrame(gameLoop);
      
      // Event listeners
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      
      // Start button click handler
      const startButton = document.getElementById('startButton');
      if (startButton) {
        startButton.addEventListener('click', () => {
          if (!gameStarted) {
            resetGame();
            startButton.classList.add('hidden');
          }
        });
      }

      // Add window resize handler
      window.addEventListener('resize', handleResize);
    }

    // Handle window resize
    function handleResize() {
      if (isMobileDevice) {
        canvasScale = window.innerWidth < 600 ? 0.8 : 1.0;
        canvas.width = 600 * canvasScale;
        canvas.height = 600 * canvasScale;
        
        // Adjust player position
        player.x = canvas.width / 2;
        player.y = canvas.height - 100;
        
        // Regenerate platforms
        generatePlatforms();
      }
    }

    // Handle key down events
    function handleKeyDown(e: KeyboardEvent) {
      if (e.key === 'ArrowLeft') keys.left = true;
      else if (e.key === 'ArrowRight') keys.right = true;
      else keys[e.key] = true;
      
      if (e.key === ' ') {
        e.preventDefault();
        if (!gameStarted || gameOver) {
          resetGame();
        }
      }
    }

    // Handle key up events
    function handleKeyUp(e: KeyboardEvent) {
      if (e.key === 'ArrowLeft') keys.left = false;
      else if (e.key === 'ArrowRight') keys.right = false;
      else keys[e.key] = false;
    }

    // Generate platforms with optimized spacing
    function generatePlatforms() {
      platforms = [];
      monsters = [];
      items = [];  // Reset items
      
      // Bottom platform
      platforms.push({
        x: canvas.width / 2 - PLATFORM_WIDTH / 2,
        y: canvas.height - 60,
        width: PLATFORM_WIDTH,
        height: PLATFORM_HEIGHT,
        type: 'normal'
      });
      
      // Generate random platforms with optimized spacing
      let lastPlatformX = canvas.width / 2;  // Track last platform position
      for (let i = 0; i < MIN_PLATFORMS; i++) {
        // Use easier spacing for first 300 points
        const spacing = score < EASY_MODE_THRESHOLD ? EASY_PLATFORM_SPACING : PLATFORM_SPACING;
        const y = canvas.height - 100 - i * spacing;
        
        // Calculate safe x position range based on last platform
        const minX = Math.max(50, lastPlatformX - MAX_JUMP_DISTANCE);
        const maxX = Math.min(canvas.width - PLATFORM_WIDTH - 50, lastPlatformX + MAX_JUMP_DISTANCE);
        const x = minX + Math.random() * (maxX - minX);
        
        // Update last platform position
        lastPlatformX = x + PLATFORM_WIDTH / 2;
        
        // Determine platform type based on score
        const platformType = score >= BRITTLE_PLATFORM_SCORE && Math.random() < BRITTLE_PLATFORM_CHANCE ? 'brittle' : 'normal';
        
        platforms.push({
          x: x,
          y: y,
          width: PLATFORM_WIDTH,
          height: PLATFORM_HEIGHT,
          type: platformType
        });
        
        // Add monsters with optimized spawn chance
        let spawnChance;
        if (score < 100) {
          spawnChance = VERY_EASY_MONSTER_SPAWN_CHANCE;
        } else if (score < EASY_MODE_THRESHOLD) {
          spawnChance = EASY_MONSTER_SPAWN_CHANCE;
        } else {
          spawnChance = MONSTER_SPAWN_CHANCE;
        }
        
        if (Math.random() < spawnChance) {
          const monsterType = determineMonsterType();
          if (monsterType) {
            monsters.push(createMonster(x, y, monsterType));
          }
        }
      }
    }

    // Determine monster type based on score
    function determineMonsterType() {
      if (score >= HYBRID_MONSTER_SCORE) {
        // At 1000+, spawn cyan monsters
        return 'hybrid';
      } else if (score >= 900) {
        // At 900+, spawn red and green monsters together
        const redMonster = createMonster(0, 0, 'basic');
        const greenMonster = createMonster(0, 0, 'advanced');
        monsters.push(redMonster, greenMonster);
        return null;
      } else if (score >= 600) {
        // At 600+, spawn yellow monsters
        return 'fast';
      } else if (score >= 400) {
        // At 400+, spawn green monsters
        return 'advanced';
      } else if (score >= 200) {
        // At 200+, spawn red monsters
        return 'basic';
      } else {
        // Below 200, no monsters
        return null;
      }
    }

    // Create monster with specific type
    function createMonster(x: number, y: number, type: Monster['type']): Monster {
      const baseX = x + PLATFORM_WIDTH / 2;
      const baseY = y - MONSTER_SIZE;
      
      const baseMonster = {
        hasDuplicated: false
      };
      
      // Apply device-specific speed multiplier
      const monsterSpeedMultiplier = isMobileDevice ? mobileMonsterSpeedMultiplier : desktopMonsterSpeedMultiplier;
      
      switch(type) {
        case 'hybrid':
          return {
            ...baseMonster,
            x: baseX - MONSTER_SIZE / 2,
            y: baseY,
            width: MONSTER_SIZE,
            height: MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'hybrid',
            color: '#00ffff',
            speed: 2 * monsterSpeedMultiplier,
            verticalSpeed: 0,
            verticalDirection: 0
          };
        case 'fast':
          return {
            ...baseMonster,
            x: baseX - SMALL_MONSTER_SIZE / 2,
            y: baseY,
            width: SMALL_MONSTER_SIZE,
            height: SMALL_MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'fast',
            color: '#ffff00',
            speed: 4 * monsterSpeedMultiplier
          };
        case 'advanced':
          return {
            ...baseMonster,
            x: baseX - LARGE_MONSTER_SIZE / 2,
            y: baseY,
            width: LARGE_MONSTER_SIZE,
            height: LARGE_MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'advanced',
            color: '#00ff00',
            speed: 1 * monsterSpeedMultiplier,
            verticalSpeed: 0,
            verticalDirection: 0
          };
        default:
          return {
            ...baseMonster,
            x: baseX - MONSTER_SIZE / 2,
            y: baseY,
            width: MONSTER_SIZE,
            height: MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'basic',
            color: '#ff0000',
            speed: 2 * monsterSpeedMultiplier
          };
      }
    }

    // Update game state
    function update() {
      if (!gameStarted || gameOver) return;
      
      // Update item display
      updateItemDisplay();
      
      // Update flicker timer
      if (!gameStarted) {
        flickerTimer++;
        if (flickerTimer >= 30) {
          titleFlicker = !titleFlicker;
          flickerTimer = 0;
        }
      }

      // Check for cutscene trigger before handling cutscene
      if (score >= DOUBLE_JUMP_UNLOCK_SCORE && !player.hasDoubleJump && !player.isInCutscene) {
        player.isInCutscene = true;
        cutsceneStartTime = Date.now();
        currentDialogue = 0;
      }

      // Handle cutscene
      if (player.isInCutscene) {
        const currentTime = Date.now();
        const elapsedTime = currentTime - cutsceneStartTime;

        // Update rainbow effect
        if (elapsedTime > CUTSCENE_DURATION) {
          player.rainbowTimer++;
          if (player.rainbowTimer >= 5) { // Change color every 5 frames
            player.currentRainbowIndex = (player.currentRainbowIndex + 1) % RAINBOW_COLORS.length;
            player.rainbowTimer = 0;
            
            // Apply rainbow effect to score display
            const scoreDisplay = document.getElementById('scoreDisplay');
            if (scoreDisplay) {
              scoreDisplay.style.color = RAINBOW_COLORS[player.currentRainbowIndex];
            }
          }
        }

        // End cutscene after both dialogues
        if (elapsedTime > CUTSCENE_DURATION * 2) {
          player.isInCutscene = false;
          player.hasDoubleJump = true;  // Unlock double jump
          
          // Reset score display color
          const scoreDisplay = document.getElementById('scoreDisplay');
          if (scoreDisplay) {
            scoreDisplay.style.color = 'white';
          }
        }
      }
      
      // Handle pointy hat cutscene
      if (pointyHatCutscenePhase > 0) {
        const currentTime = Date.now();
        const elapsedTime = currentTime - pointyHatCutsceneStartTime;
        
        // End cutscene after both dialogues
        if (elapsedTime > CUTSCENE_DURATION * 2) {
          pointyHatCutscenePhase = 0;
        }
      }
      
      // Handle Green's Gluttony cutscene
      if (greensGluttonyCutscenePhase > 0) {
        const currentTime = Date.now();
        const elapsedTime = currentTime - greensGluttonyCutsceneStartTime;
        
        // End cutscene after both dialogues
        if (elapsedTime > CUTSCENE_DURATION * 2) {
          greensGluttonyCutscenePhase = 0;
        }
      }
      
      // Player movement
      if (keys.left) player.velocityX = -MOVE_SPEED;
      else if (keys.right) player.velocityX = MOVE_SPEED;
      else player.velocityX = 0;
      
      // Apply horizontal movement
      player.x += player.velocityX;
      
      // Keep player in bounds
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
      
      // Simplified jump logic
      if (keys[' '] && !player.isJumping) {
        // First jump
        player.velocityY = JUMP_FORCE;
        player.isJumping = true;
      } else if (keys[' '] && player.isJumping && player.hasDoubleJump) {
        // Second jump (air jump)
        player.velocityY = JUMP_FORCE;
      }
      
      // Apply gravity
      player.velocityY += GRAVITY;
      player.y += player.velocityY;
      
      // Screen scrolling
      const scrollThreshold = canvas.height * SCREEN_SCROLL_THRESHOLD;
      if (player.y < scrollThreshold) {
        const scrollAmount = scrollThreshold - player.y;
        cameraY += scrollAmount;
        player.y += scrollAmount;
        
        // Move platforms and monsters with camera
        platforms.forEach(platform => {
          platform.y += scrollAmount;
        });
        monsters.forEach(monster => {
          monster.y += scrollAmount;
        });
        
        // Move items with camera
        items.forEach(item => {
          item.y += scrollAmount;
        });
        
        // Generate new platforms if needed
        const highestPlatform = Math.min(...platforms.map(p => p.y));
        if (highestPlatform > 0) {
          generateNewPlatforms();
        }
      }
      
      // Platform collision
      player.isJumping = true;
      for (let i = platforms.length - 1; i >= 0; i--) {
        const platform = platforms[i];
        if (player.y + player.height > platform.y &&
            player.y < platform.y + platform.height &&
            player.x + player.width > platform.x &&
            player.x < platform.x + platform.width) {
          if (player.velocityY > 0) {
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.isJumping = false;
            
            // Only create landing particles if we were previously jumping
            if (player.wasJumping) {
              createLandingParticles(player.x + player.width/2, player.y + player.height, '#333');
            }
            player.wasJumping = false;
            
            // Handle brittle platform
            if (platform.type === 'brittle') {
              // Start break timer if not already started
              if (!platform.breakTimer) {
                platform.breakTimer = Date.now();
              }
              
              // Check if platform should break
              if (platform.breakTimer && Date.now() - platform.breakTimer > BRITTLE_PLATFORM_BREAK_TIME) {
                // Create breaking particles
                createLandingParticles(platform.x + platform.width/2, platform.y, '#888');
                // Remove the platform
                platforms.splice(i, 1);
                // Make player fall
                player.isJumping = true;
                continue;
              }
            }
            
            // Check for cutscene trigger
            if (score >= DOUBLE_JUMP_UNLOCK_SCORE && !player.hasDoubleJump && !player.isInCutscene) {
              player.isInCutscene = true;
              cutsceneStartTime = Date.now();
              currentDialogue = 0;
            }
          }
        } else if (platform.type === 'brittle' && platform.breakTimer) {
          // Reset break timer when player is not on the platform
          platform.breakTimer = undefined;
        }
      }
      
      // Item collection
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (!item.collected && 
            player.y + player.height > item.y &&
            player.y < item.y + item.height &&
            player.x + player.width > item.x &&
            player.x < item.x + item.width) {
          
          // Collect the item
          item.collected = true;
          
          // Handle different item types
          if (item.type === 'pointyHat') {
            player.hasPointyHat = true;
            // Start pointy hat cutscene
            pointyHatCutsceneStartTime = Date.now();
            pointyHatCutscenePhase = 1;
            // Create collection particles
            createLandingParticles(item.x + item.width/2, item.y + item.height/2, '#ffffff');
          } else if (item.type === 'greensGluttony') {
            player.hasGreensGluttony = true;
            
            // Start growth animation instead of instantly changing size
            isGrowing = true;
            growthStartTime = Date.now();
            growthProgress = 0;
            
            // Start Green's Gluttony cutscene
            greensGluttonyCutsceneStartTime = Date.now();
            greensGluttonyCutscenePhase = 1;
            // Create collection particles
            createLandingParticles(item.x + item.width/2, item.y + item.height/2, '#00ff00');
          }
          
          // Remove the item
          items.splice(i, 1);
        }
      }
      
      // Update growth animation
      if (isGrowing) {
        const currentTime = Date.now();
        growthProgress = (currentTime - growthStartTime) / GROWTH_DURATION;
        
        if (growthProgress >= 1) {
          // Animation complete
          growthProgress = 1;
          isGrowing = false;
          // Set final size
          player.width = PLAYER_GLUTTONY_SIZE;
          player.height = PLAYER_GLUTTONY_SIZE;
          player.isEnlarged = true;
        } else {
          // Calculate interpolated size during animation
          const startSize = PLAYER_SIZE;
          const endSize = PLAYER_GLUTTONY_SIZE;
          const currentSize = startSize + (endSize - startSize) * easeInOutQuad(growthProgress);
          
          // Update player size
          player.width = currentSize;
          player.height = currentSize;
        }
      }
      
      // Monster collision and movement
      for (let i = monsters.length - 1; i >= 0; i--) {
        let monster = monsters[i];
        
        // Move monster based on type
        updateMonster(monster);
        
        // Check collision with player
        if (player.y + player.height > monster.y &&
            player.y < monster.y + monster.height &&
            player.x + player.width > monster.x &&
            player.x < monster.x + monster.width) {
          
          // Check if player is above the monster and has pointy hat
          if (player.velocityY > 0 && player.y + player.height < monster.y + monster.height / 2 && player.hasPointyHat) {
            // Player jumps on monster with pointy hat
            createLandingParticles(player.x + player.width/2, player.y + player.height, monster.color);
            
            // Check for Green's Gluttony drop from green monsters
            if (monster.type === 'advanced' && Math.random() < GREENS_GLUTTONY_DROP_CHANCE && !player.hasGreensGluttony && greensGluttonyDropCount < 2) {
              items.push({
                x: monster.x + monster.width / 2 - 10,
                y: monster.y,
                width: 20,
                height: 20,
                type: 'greensGluttony',
                collected: false
              });
              console.log('Green\'s Gluttony dropped from green monster');
              greensGluttonyDropCount++;
            }
            
            monsters.splice(i, 1);
            // Apply jump force when killing monster
            player.velocityY = JUMP_FORCE;
            player.isJumping = true;
          } else if (player.velocityY > 0 && player.y + player.height < monster.y + monster.height / 2) {
            // Player jumps on monster without pointy hat (normal behavior)
            createLandingParticles(player.x + player.width/2, player.y + player.height, monster.color);
            
            // Check for Green's Gluttony drop from green monsters
            if (monster.type === 'advanced' && Math.random() < GREENS_GLUTTONY_DROP_CHANCE && !player.hasGreensGluttony && greensGluttonyDropCount < 2) {
              items.push({
                x: monster.x + monster.width / 2 - 10,
                y: monster.y,
                width: 20,
                height: 20,
                type: 'greensGluttony',
                collected: false
              });
              console.log('Green\'s Gluttony dropped from green monster');
              greensGluttonyDropCount++;
            }
            
            monsters.splice(i, 1);
            // Apply jump force when killing monster
            player.velocityY = JUMP_FORCE;
            player.isJumping = true;
          } else if (player.velocityY < 0 && player.y > monster.y + monster.height / 2 && player.hasPointyHat) {
            // Player jumps up into monster from below with pointy hat
            createLandingParticles(player.x + player.width/2, player.y, monster.color);
            
            // Check for Green's Gluttony drop from green monsters
            if (monster.type === 'advanced' && Math.random() < GREENS_GLUTTONY_DROP_CHANCE && !player.hasGreensGluttony && greensGluttonyDropCount < 2) {
              items.push({
                x: monster.x + monster.width / 2 - 10,
                y: monster.y,
                width: 20,
                height: 20,
                type: 'greensGluttony',
                collected: false
              });
              console.log('Green\'s Gluttony dropped from green monster');
              greensGluttonyDropCount++;
            }
            
            monsters.splice(i, 1);
            // Apply downward force when killing monster
            player.velocityY = 2;
          } else {
            // Player hits monster from the side
            gameOver = true;
            document.getElementById('gameOver').classList.remove('hidden');
          }
        }
      }
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }
      
      // Update previous jump state
      player.wasJumping = player.isJumping;
      
      // Update score
      score = Math.floor((cameraY + canvas.height - player.y) / 10);
      document.getElementById('score').textContent = score.toString();
      document.getElementById('scoreValue').textContent = score.toString();
      
      // Check if player fell
      if (player.y > canvas.height) {
        gameOver = true;
        document.getElementById('gameOver').classList.remove('hidden');
      }

      // Apply movement speed changes based on items
      if (player.isEnlarged) {
        MOVE_SPEED = ENLARGED_MOVE_SPEED;
      } else {
        MOVE_SPEED = isMobileDevice ? mobileMoveSpeed : desktopMoveSpeed;
      }

      // Spawn Pointy Hat if not collected and score is sufficient
      if (!player.hasPointyHat && score >= POINTY_HAT_SCORE && !pointyHatSpawned) {
        // Find a platform significantly higher than the player
        const targetY = player.y - 500; // Adjusted to be higher
        const platform = platforms.find(p => p.y <= targetY && p.y + PLATFORM_HEIGHT >= targetY);
        if (platform) {
          items.push({
            x: platform.x + platform.width / 2 - 10, // Centered on the platform
            y: platform.y - 20, // Slightly above the platform
            width: 20,
            height: 20,
            type: 'pointyHat',
            collected: false
          });
          console.log('Pointy Hat spawned on higher platform');
          // Set the flag to prevent further spawning
          pointyHatSpawned = true;
        }
      }
    }

    // Generate new platforms at the top
    function generateNewPlatforms() {
      const highestPlatform = Math.min(...platforms.map(p => p.y));
      const newPlatforms = [];
      
      // Use easier spacing for first 300 points
      const spacing = score < EASY_MODE_THRESHOLD ? EASY_PLATFORM_SPACING : PLATFORM_SPACING;
      
      // Get the last platform's position
      let lastPlatformX = platforms[platforms.length - 1].x + PLATFORM_WIDTH / 2;
      
      // Determine spawn chance based on score
      let spawnChance;
      if (score < 100) {
        spawnChance = VERY_EASY_MONSTER_SPAWN_CHANCE;
      } else if (score < EASY_MODE_THRESHOLD) {
        spawnChance = EASY_MONSTER_SPAWN_CHANCE;
      } else {
        spawnChance = MONSTER_SPAWN_CHANCE;
      }
      
      // Generate more platforms at once
      for (let i = 0; i < PLATFORM_BUFFER; i++) {
        // Calculate safe x position range based on last platform
        const minX = Math.max(50, lastPlatformX - MAX_JUMP_DISTANCE);
        const maxX = Math.min(canvas.width - PLATFORM_WIDTH - 50, lastPlatformX + MAX_JUMP_DISTANCE);
        const x = minX + Math.random() * (maxX - minX);
        const y = highestPlatform - spacing - i * spacing;
        
        // Update last platform position
        lastPlatformX = x + PLATFORM_WIDTH / 2;
        
        // Determine platform type based on score
        const platformType = score >= BRITTLE_PLATFORM_SCORE && Math.random() < BRITTLE_PLATFORM_CHANCE ? 'brittle' : 'normal';
        
        newPlatforms.push({
          x: x,
          y: y,
          width: PLATFORM_WIDTH,
          height: PLATFORM_HEIGHT,
          type: platformType
        });
        
        // Add monsters with adjusted spawn chance
        if (Math.random() < spawnChance) {
          const monsterType = determineMonsterType();
          if (monsterType) {
            monsters.push(createMonster(x, y, monsterType));
          }
        }
      }
      
      platforms.push(...newPlatforms);
      
      // Remove platforms that are too far below the screen
      const screenBottom = cameraY + canvas.height;
      platforms = platforms.filter(platform => platform.y < screenBottom + 200);
    }

    // Optimize particle system
    function createLandingParticles(x: number, y: number, color: string) {
      // Limit total particles and remove oldest ones more aggressively
      if (particles.length >= MAX_PARTICLES) {
        particles.splice(0, 8); // Remove more particles at once
      }
      
      // Create fewer particles on mobile
      const particleCount = isMobileDevice ? 4 : 6; // Reduced particle count
      for (let i = 0; i < particleCount; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    // Optimize monster movement
    function updateMonster(monster: Monster) {
      // Cache frequently used values
      const playerX = player.x;
      const playerY = player.y;
      const monsterX = monster.x;
      const monsterY = monster.y;
      
      // Apply device-specific speed adjustments for vertical movement
      const verticalSpeedMultiplier = isMobileDevice ? 0.7 : 1.0;
      
      switch(monster.type) {
        case 'hybrid':
          monster.x += monster.direction * monster.speed;
          if (Math.abs(monster.x - playerX) < 100) {
            monster.verticalDirection = monster.y > playerY ? -1 : 1;
            monster.verticalSpeed = (monster.verticalSpeed || 0) + (monster.verticalDirection * 0.1 * verticalSpeedMultiplier);
            monster.verticalSpeed *= 0.98;
            monster.y += monster.verticalSpeed;

            // Check for duplication when vertically aligned
            if (!(monster as any).hasDuplicated && Math.abs(monster.x - playerX) < 30) {
              if (Math.random() < CYAN_DUPLICATION_CHANCE) {
                const duplicate = createMonster(
                  monster.x + (Math.random() < 0.5 ? -50 : 50),
                  monster.y,
                  'hybrid'
                );
                (duplicate as any).hasDuplicated = true;
                monsters.push(duplicate);
                (monster as any).hasDuplicated = true;
              }
            }
          }
          break;
        case 'fast':
          monster.x += monster.direction * monster.speed;
          break;
        case 'advanced':
          monster.x += monster.direction * monster.speed;
          if (Math.abs(monster.x - playerX) < 30) {
            monster.verticalDirection = monster.y > playerY ? -1 : 1;
            monster.verticalSpeed = (monster.verticalSpeed || 0) + (monster.verticalDirection * 0.05 * verticalSpeedMultiplier);
            monster.verticalSpeed *= 0.95;
            monster.y += monster.verticalSpeed;
          }
          break;
        default:
          monster.x += monster.direction * monster.speed;
      }

      // Keep monster in bounds
      if (monster.x < 0 || monster.x + monster.width > canvas.width) {
        monster.direction *= -1;
        // Ensure monster doesn't get stuck in wall
        monster.x = Math.max(0, Math.min(canvas.width - monster.width, monster.x));
      }
    }

    // Optimize drawing functions
    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (!gameStarted) {
        // Draw title screen
        ctx.fillStyle = '#fff';
        ctx.font = `${24 * canvasScale}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('Can you make it out, Jumpboy?', canvas.width / 2, canvas.height / 2);
      } else {
        // Draw platforms
        ctx.fillStyle = '#333';
        for (let platform of platforms) {
          if (platform.type === 'brittle') {
            ctx.fillStyle = '#222';
            
            if (platform.breakTimer) {
              const timeLeft = BRITTLE_PLATFORM_BREAK_TIME - (Date.now() - platform.breakTimer);
              const breakProgress = timeLeft / BRITTLE_PLATFORM_BREAK_TIME;
              const pulseIntensity = Math.sin(Date.now() / 200) * 0.3 + 0.7;
              ctx.fillStyle = `rgba(34, 34, 34, ${pulseIntensity})`;
              
              ctx.strokeStyle = `rgba(255, 0, 0, ${1 - breakProgress})`;
              ctx.lineWidth = 2;
              ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            }
          } else {
            ctx.fillStyle = '#333';
          }
          
          ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        }
        
        // Draw items
        for (let item of items) {
          if (!item.collected) {
            if (item.type === 'pointyHat') {
              // Add a glow effect
              ctx.shadowColor = '#ffffff';
              ctx.shadowBlur = 10;
              
              // Make the hat larger and more visible
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.moveTo(item.x + item.width / 2, item.y - 5);
              ctx.lineTo(item.x + item.width + 5, item.y + item.height);
              ctx.lineTo(item.x - 5, item.y + item.height);
              ctx.closePath();
              ctx.fill();
              
              // Reset shadow
              ctx.shadowBlur = 0;
              
              // Add a pulsing animation
              const pulse = Math.sin(Date.now() / 300) * 5;
              ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.beginPath();
              ctx.arc(item.x + item.width / 2, item.y + item.height / 2, item.width / 2 + pulse, 0, Math.PI * 2);
              ctx.fill();
            } else if (item.type === 'greensGluttony') {
              // Add a glow effect
              ctx.shadowColor = '#00ff00';
              ctx.shadowBlur = 15;
              
              // Draw the green orb
              const gradient = ctx.createRadialGradient(
                item.x + item.width/2, item.y + item.height/2, 0,
                item.x + item.width/2, item.y + item.height/2, item.width/2
              );
              gradient.addColorStop(0, '#00ff00');
              gradient.addColorStop(0.7, '#00aa00');
              gradient.addColorStop(1, '#007700');
              
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(item.x + item.width/2, item.y + item.height/2, item.width/2, 0, Math.PI * 2);
              ctx.fill();
              
              // Reset shadow
              ctx.shadowBlur = 0;
              
              // Add a pulsing animation
              const pulse = Math.sin(Date.now() / 250) * 6;
              ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
              ctx.beginPath();
              ctx.arc(item.x + item.width/2, item.y + item.height/2, item.width/2 + pulse, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
        
        // Draw monsters
        for (let monster of monsters) {
          ctx.fillStyle = monster.color;
          ctx.fillRect(monster.x, monster.y, monster.width, monster.height);
        }
        
        // Draw particles
        for (let particle of particles) {
          particle.draw(ctx);
        }
        
        // Draw player with cutscene effects
        if (player.isInCutscene) {
          drawPlayerWithCutscene();
        } else if (pointyHatCutscenePhase > 0) {
          drawPlayerWithPointyHatCutscene();
        } else if (greensGluttonyCutscenePhase > 0) {
          drawPlayerWithGreensGluttonyCutscene();
        } else {
          drawPlayerNormal();
        }
      }
    }

    // Separate player drawing functions for better organization
    function drawPlayerWithCutscene() {
      const currentTime = Date.now();
      const elapsedTime = currentTime - cutsceneStartTime;
      
      const zoomScale = 1 + Math.sin(elapsedTime / 500) * 0.2;
      ctx.save();
      ctx.translate(player.x + player.width/2, player.y + player.height/2);
      ctx.scale(zoomScale, zoomScale);
      ctx.translate(-(player.x + player.width/2), -(player.y + player.height/2));
      
      ctx.fillStyle = elapsedTime > CUTSCENE_DURATION ? RAINBOW_COLORS[player.currentRainbowIndex] : '#fff';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      ctx.restore();

      ctx.fillStyle = '#fff';
      ctx.font = `${20 * canvasScale}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(
        elapsedTime < CUTSCENE_DURATION 
          ? "Not bad, Jumpboy. You'll need this to continue"
          : "You can now double jump!",
        canvas.width / 2,
        canvas.height / 2 - 50
      );
    }

    function drawPlayerWithPointyHatCutscene() {
      const currentTime = Date.now();
      const elapsedTime = currentTime - pointyHatCutsceneStartTime;
      
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      drawPointyHat(player.x, player.y);
      
      ctx.fillStyle = '#fff';
      ctx.font = `${20 * canvasScale}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(
        elapsedTime < CUTSCENE_DURATION
          ? "It's a pointy hat."
          : "Pierce through the heavens, Jumpboy!",
        canvas.width / 2,
        canvas.height / 2 - 50
      );
    }

    function drawPlayerWithGreensGluttonyCutscene() {
      const currentTime = Date.now();
      const elapsedTime = currentTime - greensGluttonyCutsceneStartTime;
      
      // Calculate dynamic scale with pulsing effect
      const pulsingScale = 1 + Math.sin(elapsedTime / 400) * 0.1;
      
      // Combine with growth animation if still growing
      const growthScale = isGrowing ? (1 + growthProgress * 0.3) : 1;
      const totalScale = pulsingScale * growthScale;
      
      ctx.save();
      ctx.translate(player.x + player.width/2, player.y + player.height/2);
      ctx.scale(totalScale, totalScale);
      ctx.translate(-(player.x + player.width/2), -(player.y + player.height/2));
      
      // Draw enlarged player (white with green pulse)
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      const pulseIntensity = Math.sin(elapsedTime / 200) * 0.3 + 0.3; 
      ctx.strokeStyle = `rgba(0, 255, 0, ${pulseIntensity})`;
      ctx.lineWidth = 3;
      ctx.strokeRect(player.x, player.y, player.width, player.height);
      
      if (player.hasPointyHat) {
        drawPointyHat(player.x, player.y);
      }
      
      ctx.restore();
      
      ctx.fillStyle = '#fff';
      ctx.font = `${20 * canvasScale}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(
        elapsedTime < CUTSCENE_DURATION 
          ? "\"Can I just have one more bite, please?\""
          : "\"I don't know what else to do.\"",
        canvas.width / 2,
        canvas.height / 2 - 50
      );
    }

    function drawPlayerNormal() {
      ctx.fillStyle = '#fff';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Only show green glow during cutscene, not permanently
      if (player.hasPointyHat) {
        drawPointyHat(player.x, player.y);
      }
    }

    function drawPointyHat(x: number, y: number) {
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(x + player.width / 2, y - 15);
      ctx.lineTo(x + player.width + 5, y + 5);
      ctx.lineTo(x - 5, y + 5);
      ctx.closePath();
      ctx.fill();
    }

    // Optimize game loop
    function gameLoop(timestamp: number) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      frameCount++;
      if (deltaTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
      }

      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Reset game
    function resetGame() {
      player.x = canvas.width / 2;
      player.y = canvas.height - 100;
      player.velocityY = 0;
      player.velocityX = 0;
      player.isJumping = false;
      player.wasJumping = false;
      player.hasDoubleJump = false;
      player.isInCutscene = false;
      player.rainbowTimer = 0;
      player.currentRainbowIndex = 0;
      player.hasPointyHat = false;  // Reset pointy hat
      player.hasGreensGluttony = false;  // Reset Green's Gluttony
      player.isEnlarged = false;  // Reset enlarged state
      player.width = PLAYER_SIZE;  // Reset size
      player.height = PLAYER_SIZE;
      isGrowing = false;  // Reset growth animation
      growthProgress = 0;
      score = 0;
      cameraY = 0;
      gameOver = false;
      gameStarted = true;
      particles = [];
      items = [];  // Clear items array
      pointyHatCutscenePhase = 0;  // Reset pointy hat cutscene
      greensGluttonyCutscenePhase = 0;  // Reset Green's Gluttony cutscene
      document.getElementById('gameOver').classList.add('hidden');
      
      // Reset score display color
      const scoreDisplay = document.getElementById('scoreDisplay');
      if (scoreDisplay) {
        scoreDisplay.style.color = 'white';
      }
      
      const startButton = document.getElementById('startButton');
      if (startButton) {
        startButton.style.display = 'none';
      }
      generatePlatforms();

      // Reset pointy hat spawn flag
      pointyHatSpawned = false;

      // Reset Green's Gluttony drop count
      greensGluttonyDropCount = 0;
    }

    // Add mobile controls
    const mobileControls = document.getElementById('mobileControls');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    // Touch event handlers
    leftBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys.left = true;
      keys.right = false; // Ensure right is false when left is pressed
    });

    leftBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys.left = false;
    });

    rightBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys.right = true;
      keys.left = false; // Ensure left is false when right is pressed
    });

    rightBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys.right = false;
    });

    // Add touchcancel event handlers
    leftBtn.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      keys.left = false;
    });

    rightBtn.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      keys.right = false;
    });

    // Improve jump button responsiveness with debouncing
    let lastJumpTime = 0;
    jumpBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const now = Date.now();
      // Prevent multiple rapid taps (within 300ms) from triggering unintended jumps
      if (now - lastJumpTime < 300) return;
      lastJumpTime = now;
      
      if (!gameStarted || gameOver) {
        resetGame();
        return;
      }
      
      if (!player.isJumping) {
        // First jump
        player.velocityY = JUMP_FORCE;
        player.isJumping = true;
      } else if (player.isJumping && player.hasDoubleJump) {
        // Second jump (air jump)
        player.velocityY = JUMP_FORCE;
      }
    });

    // Prevent default touch behaviors
    document.addEventListener('touchmove', (e) => {
      if (e.target instanceof Element && e.target.closest('#mobileControls')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Start game when page loads
    window.addEventListener('load', init);

    // Easing function for smoother animation
    function easeInOutQuad(t: number): number {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }
  </script>
</BaseLayout> 