---
import BaseLayout from "../../layouts/BaseLayout.astro";

const post = {
  title: "Jumpboy",
  date: "March 11, 2025",
  content: `
    Make it out, boy.
  `
};
---

<BaseLayout>
  <div class="min-h-screen bg-secondary px-4 sm:px-8 py-8 sm:py-16">
    <div class="max-w-3xl mx-auto">
      <div class="flex justify-between items-center mb-6 sm:mb-8" data-aos="fade-up" data-aos-duration="1000">
        <h1 class="text-3xl sm:text-4xl font-bold text-primary hover:text-white transition-colors duration-300">
          Jumpboy
        </h1>
      </div>

      <div class="relative">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
        <button 
          id="startButton" 
          class="absolute top-[60%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-500 hover:bg-red-600 text-white px-6 py-3 rounded-lg transition-colors duration-300"
        >
          Start
        </button>
        <div id="gameOver" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black/80 text-white p-8 rounded-lg text-center">
          <h2 class="text-2xl mb-4">Game Over</h2>
          <p class="mb-4">Score: <span id="score">0</span></p>
          <p class="text-sm">Press Space to Restart</p>
        </div>
      </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls" class="fixed bottom-0 left-0 w-full h-32 bg-black/20 backdrop-blur-sm flex items-center justify-between px-8 md:hidden">
      <div class="flex space-x-4">
        <button id="leftBtn" class="w-16 h-16 rounded-full bg-white/20 flex items-center justify-center text-white text-2xl">
          ←
        </button>
        <button id="rightBtn" class="w-16 h-16 rounded-full bg-white/20 flex items-center justify-center text-white text-2xl">
          →
        </button>
      </div>
      <button id="jumpBtn" class="w-20 h-20 rounded-full bg-red-500/80 flex items-center justify-center text-white text-xl font-bold">
        Jump!
      </button>
    </div>

    <a 
      href="/blog/secret-blog" 
      class="inline-block mt-8 text-primary/60 hover:text-white transition-colors duration-300"
    >
      ← Back to Blog
    </a>
  </div>

  <style>
    .min-h-screen {
      position: relative;
      overflow: hidden;
    }

    .max-w-3xl {
      position: relative;
      z-index: 1;
    }

    #gameCanvas {
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    /* Update hover effects to use white */
    .prose :is(a, button):hover {
      color: white !important;
    }

    /* Mobile Controls Styles */
    #mobileControls button {
      transition: all 0.1s ease;
    }

    #mobileControls button:active {
      transform: scale(0.95);
    }

    #mobileControls #leftBtn:active,
    #mobileControls #rightBtn:active {
      background-color: rgba(255, 255, 255, 0.3);
    }

    #mobileControls #jumpBtn:active {
      background-color: rgba(239, 68, 68, 0.9);
    }

    /* Hide mobile controls on desktop */
    @media (min-width: 768px) {
      #mobileControls {
        display: none;
      }
    }
  </style>

  <script>
    // Game constants
    const GRAVITY = 0.5;
    const JUMP_FORCE = -12;
    const MOVE_SPEED = 4;
    const PLATFORM_HEIGHT = 12;
    const PLATFORM_WIDTH = 100;
    const MONSTER_SIZE = 30;
    const LARGE_MONSTER_SIZE = 40;
    const SMALL_MONSTER_SIZE = 20;
    const PLAYER_SIZE = 20;
    const SCREEN_SCROLL_THRESHOLD = 0.7;
    const ADVANCED_MONSTER_SCORE = 200;
    const FAST_MONSTER_SCORE = 500;
    const HYBRID_MONSTER_SCORE = 700;
    const ULTIMATE_MONSTER_SCORE = 900;
    const PLATFORM_SPACING = 80;
    const MONSTER_SPAWN_CHANCE = 0.4;
    const MAX_PARTICLES = 100;
    const PARTICLE_LIFETIME = 1;
    const PARTICLE_DECAY = 0.02;

    // Type definitions
    interface Particle {
      x: number;
      y: number;
      color: string;
      size: number;
      speedX: number;
      speedY: number;
      life: number;
      decay: number;
      update(): void;
      draw(ctx: CanvasRenderingContext2D): void;
    }

    interface Platform {
      x: number;
      y: number;
      width: number;
      height: number;
    }

    interface Monster {
      x: number;
      y: number;
      width: number;
      height: number;
      direction: number;
      type: 'basic' | 'advanced' | 'fast' | 'hybrid' | 'ultimate';
      color: string;
      speed: number;
      verticalSpeed?: number;
      verticalDirection?: number;
    }

    interface Player {
      x: number;
      y: number;
      width: number;
      height: number;
      velocityY: number;
      velocityX: number;
      isJumping: boolean;
      extraJumps: number;
      wasJumping: boolean;
    }

    interface GameKeys {
      left?: boolean;
      right?: boolean;
      [key: string]: boolean | undefined;
    }

    // Particle system
    class Particle implements Particle {
      constructor(x: number, y: number, color: string) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 3 + 1;
        this.speedX = (Math.random() - 0.5) * 4;
        this.speedY = (Math.random() - 0.5) * 4;
        this.life = 1;
        this.decay = 0.02 + Math.random() * 0.02;
      }

      update(): void {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= this.decay;
      }

      draw(ctx: CanvasRenderingContext2D): void {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
      }
    }

    // Game state
    let canvas: HTMLCanvasElement;
    let ctx: CanvasRenderingContext2D;
    let player: Player = {
      x: 0,
      y: 0,
      width: PLAYER_SIZE,
      height: PLAYER_SIZE,
      velocityY: 0,
      velocityX: 0,
      isJumping: false,
      extraJumps: 0,
      wasJumping: false
    };

    let platforms: Platform[] = [];
    let monsters: Monster[] = [];
    let particles: Particle[] = [];
    let score = 0;
    let gameOver = false;
    let gameStarted = false;
    let keys: GameKeys = {};
    let cameraY = 0;
    let titleFlicker = true;
    let flickerTimer = 0;
    let lastTime = 0;
    let frameCount = 0;
    let fps = 0;

    // Initialize game
    function init() {
      canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
      ctx = canvas.getContext('2d')!;
      
      // Set canvas size (narrower width)
      canvas.width = 600;
      canvas.height = 600;
      
      // Set initial player position
      player.x = canvas.width / 2;
      player.y = canvas.height - 100;
      
      // Generate initial platforms
      generatePlatforms();
      
      // Start game loop with timestamp
      requestAnimationFrame(gameLoop);
      
      // Event listeners
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      
      // Start button click handler
      const startButton = document.getElementById('startButton');
      if (startButton) {
        startButton.addEventListener('click', () => {
          if (!gameStarted) {
            resetGame();
            startButton.classList.add('hidden');
          }
        });
      }
    }

    // Handle key down events
    function handleKeyDown(e: KeyboardEvent) {
      keys[e.key] = true;
      if (e.key === ' ') {
        e.preventDefault();
        if (!gameStarted || gameOver) {
          resetGame();
        }
      }
    }

    // Handle key up events
    function handleKeyUp(e: KeyboardEvent) {
      keys[e.key] = false;
    }

    // Generate platforms with optimized spacing
    function generatePlatforms() {
      platforms = [];
      monsters = [];
      
      // Bottom platform
      platforms.push({
        x: canvas.width / 2 - PLATFORM_WIDTH / 2,
        y: canvas.height - 60,
        width: PLATFORM_WIDTH,
        height: PLATFORM_HEIGHT
      });
      
      // Generate random platforms with optimized spacing
      for (let i = 0; i < 10; i++) {
        const minX = 50;
        const maxX = canvas.width - PLATFORM_WIDTH - 50;
        const x = minX + Math.random() * (maxX - minX);
        const y = canvas.height - 100 - i * PLATFORM_SPACING;
        
        platforms.push({
          x: x,
          y: y,
          width: PLATFORM_WIDTH,
          height: PLATFORM_HEIGHT
        });
        
        // Add monsters with optimized spawn chance
        if (Math.random() < MONSTER_SPAWN_CHANCE) {
          const monsterType = determineMonsterType();
          monsters.push(createMonster(x, y, monsterType));
        }
      }
    }

    // Determine monster type based on score
    function determineMonsterType() {
      if (score >= ULTIMATE_MONSTER_SCORE) {
        return 'ultimate';
      } else if (score >= HYBRID_MONSTER_SCORE) {
        return 'hybrid';
      } else if (score >= FAST_MONSTER_SCORE) {
        return 'fast';
      } else if (score >= ADVANCED_MONSTER_SCORE) {
        return 'advanced';
      }
      return 'basic';
    }

    // Create monster with specific type
    function createMonster(x, y, type) {
      const baseX = x + PLATFORM_WIDTH / 2;
      const baseY = y - MONSTER_SIZE;
      
      switch(type) {
        case 'ultimate':
          return {
            x: baseX - MONSTER_SIZE / 2,
            y: baseY,
            width: MONSTER_SIZE,
            height: MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'ultimate',
            color: '#ffff00',
            speed: 4,
            verticalSpeed: 0,
            verticalDirection: 0
          };
        case 'hybrid':
          return {
            x: baseX - MONSTER_SIZE / 2,
            y: baseY,
            width: MONSTER_SIZE,
            height: MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'hybrid',
            color: '#00ffff',
            speed: 2,
            verticalSpeed: 0,
            verticalDirection: 0
          };
        case 'fast':
          return {
            x: baseX - SMALL_MONSTER_SIZE / 2,
            y: baseY,
            width: SMALL_MONSTER_SIZE,
            height: SMALL_MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'fast',
            color: '#ffff00',
            speed: 3
          };
        case 'advanced':
          return {
            x: baseX - LARGE_MONSTER_SIZE / 2,
            y: baseY,
            width: LARGE_MONSTER_SIZE,
            height: LARGE_MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'advanced',
            color: '#00ff00',
            speed: 1,
            verticalSpeed: 0,
            verticalDirection: 0
          };
        default:
          return {
            x: baseX - MONSTER_SIZE / 2,
            y: baseY,
            width: MONSTER_SIZE,
            height: MONSTER_SIZE,
            direction: Math.random() < 0.5 ? -1 : 1,
            type: 'basic',
            color: '#ff0000',
            speed: 2
          };
      }
    }

    // Update game state
    function update() {
      if (!gameStarted || gameOver) return;
      
      // Update flicker timer
      if (!gameStarted) {
        flickerTimer++;
        if (flickerTimer >= 30) { // Change every 30 frames (about 0.5 seconds)
          titleFlicker = !titleFlicker;
          flickerTimer = 0;
        }
      }
      
      // Player movement
      if (keys['ArrowLeft']) player.velocityX = -MOVE_SPEED;
      else if (keys['ArrowRight']) player.velocityX = MOVE_SPEED;
      else player.velocityX = 0;
      
      // Apply horizontal movement
      player.x += player.velocityX;
      
      // Keep player in bounds
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
      
      // Jump
      if (keys[' '] && !player.isJumping && player.extraJumps > 0) {
        player.velocityY = JUMP_FORCE;
        player.isJumping = true;
        player.extraJumps--;
      }
      
      // Apply gravity
      player.velocityY += GRAVITY;
      player.y += player.velocityY;
      
      // Screen scrolling
      const scrollThreshold = canvas.height * SCREEN_SCROLL_THRESHOLD;
      if (player.y < scrollThreshold) {
        const scrollAmount = scrollThreshold - player.y;
        cameraY += scrollAmount;
        player.y += scrollAmount;
        
        // Move platforms and monsters with camera
        platforms.forEach(platform => {
          platform.y += scrollAmount;
        });
        monsters.forEach(monster => {
          monster.y += scrollAmount;
        });
        
        // Generate new platforms if needed
        const highestPlatform = Math.min(...platforms.map(p => p.y));
        if (highestPlatform > 0) {
          generateNewPlatforms();
        }
      }
      
      // Platform collision
      player.isJumping = true;
      for (let platform of platforms) {
        if (player.y + player.height > platform.y &&
            player.y < platform.y + platform.height &&
            player.x + player.width > platform.x &&
            player.x < platform.x + platform.width) {
          if (player.velocityY > 0) {
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.isJumping = false;
            player.extraJumps = 1;
            
            // Create landing particles if we just landed
            if (player.wasJumping) {
              createLandingParticles(player.x + player.width/2, player.y + player.height, '#333');
            }
          }
        }
      }
      
      // Monster collision and movement
      for (let i = monsters.length - 1; i >= 0; i--) {
        let monster = monsters[i];
        
        // Move monster based on type
        updateMonster(monster);
        
        // Check collision with player
        if (player.y + player.height > monster.y &&
            player.y < monster.y + monster.height &&
            player.x + player.width > monster.x &&
            player.x < monster.x + monster.width) {
          if (player.velocityY > 0) {
            // Player jumps on monster
            createLandingParticles(player.x + player.width/2, player.y + player.height, monster.color);
            monsters.splice(i, 1);
            player.extraJumps++;
            // Apply jump force when killing monster
            player.velocityY = JUMP_FORCE;
            player.isJumping = true;
          } else {
            // Player hits monster
            gameOver = true;
            document.getElementById('gameOver').classList.remove('hidden');
          }
        }
      }
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }
      
      // Update previous jump state
      player.wasJumping = player.isJumping;
      
      // Update score
      score = Math.floor((cameraY + canvas.height - player.y) / 10);
      document.getElementById('score').textContent = score.toString();
      
      // Check if player fell
      if (player.y > canvas.height) {
        gameOver = true;
        document.getElementById('gameOver').classList.remove('hidden');
      }
    }

    // Generate new platforms at the top
    function generateNewPlatforms() {
      const highestPlatform = Math.min(...platforms.map(p => p.y));
      const newPlatforms = [];
      
      for (let i = 0; i < 3; i++) {
        const minX = 50;
        const maxX = canvas.width - PLATFORM_WIDTH - 50;
        const x = minX + Math.random() * (maxX - minX);
        const y = highestPlatform - 80 - i * 80;
        
        newPlatforms.push({
          x: x,
          y: y,
          width: PLATFORM_WIDTH,
          height: PLATFORM_HEIGHT
        });
        
        // Add monsters more frequently
        if (Math.random() < 0.4) {
          const monsterType = determineMonsterType();
          monsters.push(createMonster(x, y, monsterType));
        }
      }
      
      platforms.push(...newPlatforms);
    }

    // Optimize particle system
    function createLandingParticles(x: number, y: number, color: string) {
      // Limit total particles
      if (particles.length >= MAX_PARTICLES) {
        particles.splice(0, 4); // Remove oldest particles
      }
      
      for (let i = 0; i < 8; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    // Optimize monster movement
    function updateMonster(monster: Monster) {
      switch(monster.type) {
        case 'ultimate':
          monster.x += monster.direction * monster.speed;
          if (Math.abs(monster.x - player.x) < 50) {
            monster.verticalDirection = monster.y > player.y ? -1 : 1;
            monster.verticalSpeed = (monster.verticalSpeed || 0) + (monster.verticalDirection * 0.2);
            monster.verticalSpeed *= 0.95;
            monster.y += monster.verticalSpeed;
          }
          break;
        case 'hybrid':
          monster.x += monster.direction * monster.speed;
          if (Math.abs(monster.x - player.x) < 100) {
            monster.verticalDirection = monster.y > player.y ? -1 : 1;
            monster.verticalSpeed = (monster.verticalSpeed || 0) + (monster.verticalDirection * 0.1);
            monster.verticalSpeed *= 0.98;
            monster.y += monster.verticalSpeed;
          }
          break;
        case 'fast':
          monster.x += monster.direction * monster.speed;
          break;
        case 'advanced':
          monster.x += monster.direction * monster.speed;
          if (Math.abs(monster.x - player.x) < 30) {
            monster.verticalDirection = monster.y > player.y ? -1 : 1;
            monster.verticalSpeed = (monster.verticalSpeed || 0) + (monster.verticalDirection * 0.1);
            monster.verticalSpeed *= 0.98;
            monster.y += monster.verticalSpeed;
          }
          break;
        default:
          monster.x += monster.direction * monster.speed;
      }

      // Keep monster in bounds
      if (monster.x < 0 || monster.x + monster.width > canvas.width) {
        monster.direction *= -1;
      }
    }

    // Draw game
    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (!gameStarted) {
        // Draw title screen
        ctx.fillStyle = '#fff';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Can you make it out, Jumpboy?', canvas.width / 2, canvas.height / 2);
      } else {
        // Draw platforms
        ctx.fillStyle = '#333';
        for (let platform of platforms) {
          ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        }
        
        // Draw monsters
        for (let monster of monsters) {
          ctx.fillStyle = monster.color;
          ctx.fillRect(monster.x, monster.y, monster.width, monster.height);
        }
        
        // Draw particles
        for (let particle of particles) {
          particle.draw(ctx);
        }
        
        // Draw player
        ctx.fillStyle = '#fff';
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }
    }

    // Optimize game loop with FPS counter
    function gameLoop(timestamp: number) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      frameCount++;
      if (deltaTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
      }

      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Reset game
    function resetGame() {
      player.x = canvas.width / 2;
      player.y = canvas.height - 100;
      player.velocityY = 0;
      player.velocityX = 0;
      player.isJumping = false;
      player.wasJumping = false;
      player.extraJumps = 1;
      score = 0;
      cameraY = 0;
      gameOver = false;
      gameStarted = true;
      particles = [];
      document.getElementById('gameOver').classList.add('hidden');
      const startButton = document.getElementById('startButton');
      if (startButton) {
        startButton.style.display = 'none'; // Use display: none instead of classList.add('hidden')
      }
      generatePlatforms();
    }

    // Add mobile controls
    const mobileControls = document.getElementById('mobileControls');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    // Touch event handlers
    leftBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys.left = true;
      keys.right = false; // Ensure right is false when left is pressed
    });

    leftBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys.left = false;
    });

    rightBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys.right = true;
      keys.left = false; // Ensure left is false when right is pressed
    });

    rightBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys.right = false;
    });

    // Add touchcancel event handlers
    leftBtn.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      keys.left = false;
    });

    rightBtn.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      keys.right = false;
    });

    jumpBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (!player.isJumping) {
        player.velocityY = JUMP_FORCE;
        player.isJumping = true;
      }
    });

    // Prevent default touch behaviors
    document.addEventListener('touchmove', (e) => {
      if (e.target.closest('#mobileControls')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Start game when page loads
    window.addEventListener('load', init);
  </script>
</BaseLayout> 